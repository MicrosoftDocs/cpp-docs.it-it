---
description: 'Altre informazioni su: errori del compilatore C3200 tramite C3299'
title: Errori del compilatore da C3200 a C3299
ms.date: 04/21/2019
f1_keywords:
- C3220
- C3221
- C3245
- C3249
- C3250
- C3256
- C3257
- C3258
- C3259
- C3260
- C3261
- C3263
- C3267
- C3281
- C3294
helpviewer_keywords:
- C3220
- C3221
- C3245
- C3249
- C3250
- C3256
- C3257
- C3258
- C3259
- C3260
- C3261
- C3263
- C3267
- C3281
- C3294
ms.assetid: 6b3104f6-63bc-4823-b6f3-b8a16be4b87f
ms.openlocfilehash: e54d980634372099d76d9f30020f68f3f4affb59
ms.sourcegitcommit: d6af41e42699628c3e2e6063ec7b03931a49a098
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 12/11/2020
ms.locfileid: "97238661"
---
# <a name="compiler-errors-c3200-through-c3299"></a>Errori del compilatore da C3200 a C3299

Negli articoli di questa sezione della documentazione viene illustrato un subset dei messaggi di errore generati dal compilatore.

[!INCLUDE[error-boilerplate](../../error-messages/includes/error-boilerplate.md)]

## <a name="error-messages"></a>Messaggi di errore

|Errore|Message|
|-----------|-------------|
|[Errore del compilatore C3200](compiler-error-c3200.md)|'*Type*': argomento di modello non valido per il parametro di modello '*Parameter*'. previsto un modello di classe|
|[Errore del compilatore C3201](compiler-error-c3201.md)|l'elenco dei parametri di modello per il modello di classe '*template*' non corrisponde all'elenco dei parametri di modello per il parametro di modello '*Parameter*'|
|[Errore del compilatore C3202](compiler-error-c3202.md)|'*Identifier*': argomento predefinito non valido. previsto un modello di classe|
|[Errore del compilatore C3203](compiler-error-c3203.md)|'*Identifier*': non è possibile usare un modello di classe o un generico non specializzato come argomento Template/Generic per il parametro template/Generic '*Parameter*'. previsto un tipo reale|
|[Errore del compilatore C3204](compiler-error-c3204.md)|'*Function*' non può essere chiamato dall'interno di un blocco catch|
|[Errore del compilatore C3205](compiler-error-c3205.md)|elenco di argomenti per il parametro di modello '*Identifier*' mancante|
|[Errore del compilatore C3206](compiler-error-c3206.md)|'*Function*': argomento di modello o generico non valido per '*template*', elenco di argomenti generici/modello mancante nel modello di classe/generico '*Type*'|
|[Errore del compilatore C3207](compiler-error-c3207.md)|'*Function*': argomento di modello non valido per '*Parameter*'. previsto modello di classe|
|[Errore del compilatore C3208](compiler-error-c3208.md)|'*Function*': l'elenco dei parametri di modello per il modello di classe '*template*' non corrisponde all'elenco dei parametri di modello per il parametro di modello '*Parameter*'|
|[Errore del compilatore C3209](compiler-error-c3209.md)|'*Type*': la classe generica deve essere una classe gestita/WinRT|
|[Errore del compilatore C3210](compiler-error-c3210.md)|'*Identifier*': la dichiarazione di accesso può essere applicata solo a un membro della classe base|
|[Errore del compilatore C3211](compiler-error-c3211.md)|'*Function*': la specializzazione esplicita usa la sintassi di specializzazione parziale. utilizzare invece il modello <> |
|[Errore del compilatore C3212](compiler-error-c3212.md)|'*Function*': una specializzazione esplicita di un membro di un modello deve essere un membro di una specializzazione esplicita|
|[Errore del compilatore C3213](compiler-error-c3213.md)|la classe base '*Class*' è meno accessibile di '*Derived_Class*'|
|[Errore del compilatore C3214](compiler-error-c3214.md)|'*argument*': argomento di tipo non valido per il parametro generico '*Parameter*' del '*tipo*' generico. non soddisfa il vincolo '*Constraint*'|
|[Errore del compilatore C3215](compiler-error-c3215.md)|'*vincolo1*': parametro di tipo generico già vincolato da'*vincolo2*'|
|[Errore del compilatore C3216](compiler-error-c3216.md)|il vincolo deve essere un parametro generico, non '*Type*'|
|[Errore del compilatore C3217](compiler-error-c3217.md)|'*Parameter*': un parametro generico non può essere vincolato in questa dichiarazione|
|[Errore del compilatore C3218](compiler-error-c3218.md)|'*Type*': tipo non consentito come vincolo|
|[Errore del compilatore C3219](compiler-error-c3219.md)|'*Parameter*': il parametro generico non può essere vincolato da più interfacce non:'*Type*'|
|Errore del compilatore C3220|'*Interface*': l'interfaccia non può avere ProgID|
|Errore del compilatore C3221|'*member*': più attributi ' default ' è case ' non consentiti in un membro|
|[Errore del compilatore C3222](compiler-error-c3222.md)|'*Function*': Impossibile dichiarare argomenti predefiniti per funzioni membro di un tipo gestito/WinRT o funzioni generiche|
|[Errore del compilatore C3223](compiler-error-c3223.md)|'*Property*': non è possibile applicare ' TypeId ' a una proprietà|
|[Errore del compilatore C3224](compiler-error-c3224.md)|'*Type*': nessuna classe generica in overload accetta '*Number*' argomenti di tipo generico|
|[Errore del compilatore C3225](compiler-error-c3225.md)|l'argomento di tipo generico per '*argument*' non può essere '*Type*'. deve essere un tipo di valore o un handle per un tipo di riferimento|
|[Errore del compilatore C3226](compiler-error-c3226.md)|Dichiarazione di modello non consentita all'interno di una dichiarazione generica|
|[Errore del compilatore C3227](compiler-error-c3227.md)|'*Type*': Impossibile utilizzare '*operator*' per allocare un tipo generico|
|[Errore del compilatore C3228](compiler-error-c3228.md)|'*Function*': l'argomento di tipo generico per '*argument*' non può essere '*Type*'. deve essere un tipo di valore o un tipo di handle|
|[Errore del compilatore C3229](compiler-error-c3229.md)|'*Type*': i riferimenti indiretti in un parametro di tipo generico non sono consentiti|
|[Errore del compilatore C3230](compiler-error-c3230.md)|'*Function*': l'argomento di tipo modello per '*argument*' non può contenere un parametro di tipo generico:'*Type*'|
|[Errore del compilatore C3231](compiler-error-c3231.md)|'*Type*': l'argomento di tipo modello non può usare un parametro di tipo generico|
|[Errore del compilatore C3232](compiler-error-c3232.md)|'*Parameter*': non è possibile usare un parametro di tipo generico in un nome completo|
|[Errore del compilatore C3233](compiler-error-c3233.md)|'*Type*': parametro di tipo generico già vincolato|
|[Errore del compilatore C3234](compiler-error-c3234.md)|una classe generica non può derivare da un parametro di tipo generico|
|[Errore del compilatore C3235](compiler-error-c3235.md)|'*Speciality*': la specializzazione esplicita o parziale di una classe generica non è consentita|
|[Errore del compilatore C3236](compiler-error-c3236.md)|creazione di istanza esplicita di un elemento CLR generico non consentita|
|[Errore del compilatore C3237](compiler-error-c3237.md)|'*Class*': una classe generica non può essere un attributo personalizzato|
|[Errore del compilatore C3238](compiler-error-c3238.md)|'*Type*': un tipo con questo nome è già stato inviato all'assembly '*assembly*'|
|[Errore del compilatore C3239](compiler-error-c3239.md)|'*Type*': il puntatore al puntatore interno/di blocco non è consentito dalla Common Language Runtime|
|[Errore del compilatore C3240](compiler-error-c3240.md)|'*Identifier*': deve essere una funzione membro astratta non di overload di '*Type*'|
|[Errore del compilatore C3241](compiler-error-c3241.md)|'*member*': questo metodo non è stato introdotto da'*Interface*'|
|[Errore del compilatore C3242](compiler-error-c3242.md)|'*Function*': è possibile eseguire solo l'override esplicito delle funzioni virtuali|
|[Errore del compilatore C3243](compiler-error-c3243.md)|nessuna delle funzioni di overload è stata introdotta da'*Interface*'|
|[Errore del compilatore C3244](compiler-error-c3244.md)|'*member*': questo metodo è stato introdotto da'*interfaccia1*' non da'*Interface2*'|
|Errore del compilatore C3245|'*Function*': l'uso di un modello di variabile richiede un elenco di argomenti di modello|
|[Errore del compilatore C3246](compiler-error-c3246.md)|'*Class*': non è possibile ereditare da'*BASE_CLASS*' perché è stato dichiarato come '*ereditarietà*'|
|[Errore del compilatore C3247](compiler-error-c3247.md)|'*coclass*': una coclasse non può ereditare da un'altra coclasse '*BASE_CLASS*'|
|[Errore del compilatore C3248](compiler-error-c3248.md)|Obsoleta. '*Function*': la funzione dichiarata come ' sealed ' non può essere sottoposta a override da'*Function*'|
|Errore del compilatore C3249|istruzione o espressione secondaria non valida per la funzione ' constExpr '|
|Errore del compilatore C3250|'*Declaration*': la dichiarazione non è consentita nel corpo della funzione ' constExpr '|
|[Errore del compilatore C3251](compiler-error-c3251.md)|impossibile chiamare un metodo di una classe base su un'istanza di tipo valore|
|[Errore del compilatore C3252](compiler-error-c3252.md)|'*Function*': non è possibile ridurre l'accessibilità di un metodo virtuale in un tipo gestito/WinRT|
|[Errore del compilatore C3253](compiler-error-c3253.md)|'*Function*': errore con override esplicito|
|[Errore del compilatore C3254](compiler-error-c3254.md)|'*Function*': la classe contiene un override esplicito '*Function*' ma non deriva da un'interfaccia che contiene la dichiarazione di funzione|
|[Errore del compilatore C3255](compiler-error-c3255.md)|'*Type*': Impossibile allocare in modo dinamico questo oggetto tipo di valore nell'heap nativo|
|Errore del compilatore C3256|'*Function*': l'uso della variabile non produce un'espressione costante|
|Errore del compilatore C3257|Obsoleta.|
|Errore del compilatore C3258|Obsoleta.|
|Errore del compilatore C3259|le funzioni ' constExpr ' possono avere una sola istruzione return|
|Errore del compilatore C3260|'*token*': i token imprevisti prima del corpo dell'espressione lambda verranno ignorati|
|Errore del compilatore C3261|una funzione che restituisce una matrice gestita/WinRT deve contenere parentesi quadre alla fine della dichiarazione:'*Identifier*(...) []'|
|[Errore del compilatore C3262](compiler-error-c3262.md)|indicizzazione matrice non valida: dimensione *numerica* *specificata per il* tipo '*Type*'.|
|Errore del compilatore C3263|Obsoleta.|
|[Errore del compilatore C3264](compiler-error-c3264.md)|'*Identifier*': un costruttore di classe non può avere un tipo restituito|
|[Errore del compilatore C3265](compiler-error-c3265.md)|non è possibile dichiarare un oggetto '*managed_construct*' gestito in un'*unmanaged_construct*' non gestito|
|[Errore del compilatore C3266](compiler-error-c3266.md)|'*Function*': un costruttore di classe deve avere un elenco di parametri ' void '|
|Errore del compilatore C3267|Obsoleta.|
|[Errore del compilatore C3268](compiler-error-c3268.md)|'*Function*': una funzione generica o una funzione membro di una classe generica non può avere un elenco di parametri variabili|
|[Errore del compilatore C3269](compiler-error-c3269.md)|'*Function*': una funzione membro di un tipo gestito/WinRT non può essere dichiarata con '.. .'|
|[Errore del compilatore C3270](compiler-error-c3270.md)|'*Field*': l'attributo FieldOffset può essere usato solo nel contesto di StructLayout (LayoutKind:: Explicit)|
|[Errore del compilatore C3271](compiler-error-c3271.md)|'*Field*': valore '*Number*' non valido per l'attributo FieldOffset|
|[Errore del compilatore C3272](compiler-error-c3272.md)|'*Symbol*': il simbolo richiede fieldOffset, poiché è un membro di struct/Class *Type_name* definito con StructLayout (LayoutKind:: Explicit)|
|[Errore del compilatore C3273](compiler-error-c3273.md)|'*keyword*': non consentito in un blocco try C++|
|[Errore del compilatore C3274](compiler-error-c3274.md)|Infine/&#95;&#95;infine senza try corrispondente|
|[Errore del compilatore C3275](compiler-error-c3275.md)|'*Identifier*': Impossibile utilizzare questo simbolo senza qualificatore|
|[Errore del compilatore C3276](compiler-error-c3276.md)|'*keyword*': il salto dal blocco finally/&#95;&#95;finally presenta un comportamento non definito durante la gestione della terminazione|
|[Errore del compilatore C3277](compiler-error-c3277.md)|non è possibile definire un'enumerazione non gestità *Enumeration*' all'interno di '*Type*' gestito|
|[Errore del compilatore C3278](compiler-error-c3278.md)|la chiamata diretta del metodo di interfaccia o puro '*Function*' avrà esito negativo in fase di esecuzione|
|[Errore del compilatore C3279](compiler-error-c3279.md)|le specializzazioni parziali ed esplicite e le creazioni di istanze esplicite di modelli di classe dichiarati nello spazio dei nomi cli non sono consentite|
|[Errore del compilatore C3280](compiler-error-c3280.md)|'*Function*': una funzione membro di un tipo gestito non può essere compilata come funzione non gestita|
|Errore del compilatore C3281|'*Function*': l'operatore globale non può avere il tipo gestito/WinRT '*Type*' nella firma|
|[Errore del compilatore C3282](compiler-error-c3282.md)|gli elenchi di parametri generici possono essere visualizzati solo su classi, struct o funzioni gestite/WinRT|
|[Errore del compilatore C3283](compiler-error-c3283.md)|'*Interface*': un'interfaccia non può avere un costruttore di istanza|
|[Errore del compilatore C3284](compiler-error-c3284.md)|i vincoli per il parametro generico '*Parameter*' della funzione '*dichiarator*' devono corrispondere ai vincoli per il parametro generico '*Parameter*' della funzione '*dichiarator*'|
|[Errore del compilatore C3285](compiler-error-c3285.md)|per ogni istruzione non è possibile utilizzare variabili di tipo '*Type*'|
|[Errore del compilatore C3286](compiler-error-c3286.md)|'*specifier*': una variabile di iterazione non può avere identificatori di classe di archiviazione|
|[Errore del compilatore C3287](compiler-error-c3287.md)|il tipo '*Type*' (tipo restituito di GetEnumerator) deve avere una funzione membro MoveNext pubblica adatta e una proprietà Current pubblica|
|[Errore del compilatore C3288](compiler-error-c3288.md)|'*Type*': dereferenziazione non valida di un tipo di handle|
|[Errore del compilatore C3289](compiler-error-c3289.md)|'*Identifier*': Impossibile indicizzare una proprietà semplice|
|[Errore del compilatore C3290](compiler-error-c3290.md)|'*Type*': una proprietà Trivial non può avere un tipo riferimento|
|[Errore del compilatore C3291](compiler-error-c3291.md)|' default ': non può essere il nome di una proprietà semplice|
|[Errore del compilatore C3292](compiler-error-c3292.md)|impossibile riaprire lo spazio dei nomi cli|
|[Errore del compilatore C3293](compiler-error-c3293.md)|'*Identifier*': usare ' default ' per accedere alla proprietà predefinita (indexer) per la classe '*Class*'|
|Errore del compilatore C3294|Obsoleta.|
|[Errore del compilatore C3295](compiler-error-c3295.md)|' #pragma *specifier*' può essere usato solo nell'ambito globale o dello spazio dei nomi|
|[Errore del compilatore C3296](compiler-error-c3296.md)|'*Identifier*': esiste già una proprietà con questo nome|
|[Errore del compilatore C3297](compiler-error-c3297.md)|' *vincolo2*': non è possibile usare ' *vincolo1*' come vincolo perché' *vincolo1*' contiene il vincolo value|
|[Errore del compilatore C3298](compiler-error-c3298.md)|' *vincolo1*': non è possibile usare ' *vincolo2*' come vincolo perché' *vincolo2*' contiene il vincolo Ref è *vincolo1*' contiene il vincolo value|
|[Errore del compilatore C3299](compiler-error-c3299.md)|' *Function*': Impossibile specificare vincoli perché vengono ereditati dal metodo base|

## <a name="see-also"></a>Vedi anche

[Errori e avvisi degli strumenti di compilazione e compilatore C/C++](../compiler-errors-1/c-cpp-build-errors.md) \
[Errori del compilatore da C2000 a C3999](../compiler-errors-1/compiler-errors-c2000-c3999.md)
